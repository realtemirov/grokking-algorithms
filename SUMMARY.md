# Table of contents

* [Content](README.md)
* [Introduction to Algorithms](<1. Introduction to Algorithms/README.md>)
  * [Introduction](<1. Introduction to Algorithms/1. Introduction.md>)
  * [Binary Search](<1. Introduction to Algorithms/2. Binary Search.md>)
  * [Big O notation](<1. Introduction to Algorithms/3. Big O notation.md>)
  * [Recap](<1. Introduction to Algorithms/4. Recap.md>)
* [Selection sort](<2. Selection sort/README.md>)
  * [How memory works](<2. Selection sort/1. How memory works.md>)
  * [Arrays and linked lists](<2. Selection sort/2. Arrays and linked lists.md>)
  * [Selection sort](<2. Selection sort/3. Selection sort.md>)
  * [Recap](<2. Selection sort/4. Recap.md>)
* [Recursion](<3. Recursion/README.md>)
  * [Recursion](<3. Recursion/1. Recursion.md>)
  * [Base case and recursive case](<3. Recursion/2. Base case and recursive case.md>)
  * [The stack](<3. Recursion/3. The stack.md>)
  * [Recap](<3. Recursion/4. Recap.md>)
* [Quicksort](<4. Quicksort/README.md>)
  * [Divide & conquer](<4. Quicksort/1. Divide & conquer.md>)
  * [Quicksort](<4. Quicksort/2. Quicksort.md>)
  * [Big O notation revisited](<4. Quicksort/3. Big O notation revisited.md>)
  * [Recap](<4. Quicksort/4. Recap.md>)
* [Hash tables](<5. Hash tables/README.md>)
  * [Hash functions](<5. Hash tables/1. Hash functions.md>)
  * [Use cases](<5. Hash tables/2. Use cases.md>)
  * [Collisions](<5. Hash tables/3. Collisions.md>)
  * [Performance](<5. Hash tables/4. Performance.md>)
  * [Recap](<5. Hash tables/5. Recap.md>)
* [Breadth-first search](<6. Breadth-first search/README.md>)
  * [Introduction to graph](<6. Breadth-first search/1. Introduction to graph.md>)
  * [What is a graph](<6. Breadth-first search/2. What is a graph.md>)
  * [Breadth-first search](<6. Breadth-first search/3. Breadth-first search.md>)
  * [Implementing the graph](<6. Breadth-first search/4. Implementing the graph.md>)
  * [Implementing the algorithm](<6. Breadth-first search/5. Implementing the algorithm.md>)
  * [Recap](<6. Breadth-first search/6. Recap.md>)
* [Dijkstra's algorithm](<7. Dijkstra's algorithm/README.md>)
  * [Working with Dijkstra's algorithm](<7. Dijkstra's algorithm/1. Working with Dijkstra's algorithm.md>)
  * [Terminology](<7. Dijkstra's algorithm/2. Terminology.md>)
  * [Trading for a piano](<7. Dijkstra's algorithm/3. Trading for a piano.md>)
  * [Negative-weight edges](<7. Dijkstra's algorithm/4. Negative-weight edges.md>)
  * [Implementation](<7. Dijkstra's algorithm/5. Implementation.md>)
  * [Recap](<7. Dijkstra's algorithm/6. Recap.md>)
* [Greedy Algorithms](<8. Greedy Algorithms/README.md>)
  * [The classroom scheduling problem](<8. Greedy Algorithms/1. The classroom scheduling problem.md>)
  * [The knapsack problem](<8. Greedy Algorithms/2. The knapsack problem.md>)
  * [The set-covering problem](<8. Greedy Algorithms/3. The set-covering problem.md>)
  * [NP-complete problems](<8. Greedy Algorithms/4. NP-complete problems.md>)
  * [Traveling salesperson, step by step](<8. Greedy Algorithms/5. Traveling salesperson, step by step.md>)
  * [Recap](<8. Greedy Algorithms/6. Recap.md>)
* [Dynamic programming](<9. Dynamic programming/README.md>)
  * [The knapsack problem](<9. Dynamic programming/1. The knapsack problem.md>)
  * [Knapsack problem FAQ](<9. Dynamic programming/2. Knapsack problem FAQ.md>)
  * [Longest common substring](<9. Dynamic programming/3. Longest common substring.md>)
  * [Recap](<9. Dynamic programming/4. Recap.md>)
* [K-nearest neighbors](<10. K-nearest neighbors/README.md>)
  * [Classifying oranges vs. grapefruit](<10. K-nearest neighbors/1. Classifying oranges vs. grapefruit.md>)
  * [Building a recommendations system](<10. K-nearest neighbors/2. Building a recommendations system.md>)
  * [Introduction to machine learning](<10. K-nearest neighbors/3. Introduction to machine learning.md>)
  * [Recap](<10. K-nearest neighbors/4. Recap.md>)
* [Where to go next](<11. Where to go next/1. Trees.md>)
  * [Inverted indexes](<11. Where to go next/2. Inverted indexes.md>)
  * [The Fourier transform](<11. Where to go next/3. The Fourier transform.md>)
  * [Parallel algorithms](<11. Where to go next/4. Parallel algorithms.md>)
  * [MapReduce](<11. Where to go next/5. MapReduce.md>)
  * [Bloom filters and HyperLogLog](<11. Where to go next/6. Bloom filters and HyperLogLog.md>)
  * [The SHA algorithms](<11. Where to go next/7. The SHA algorithms.md>)
  * [Locality-sensitive hashing](<11. Where to go next/8. Locality-sensitive hashing.md>)
  * [Diffie-Hellman key exchange](<11. Where to go next/9. Diffie-Hellman key exchange.md>)
  * [Linear programming](<11. Where to go next/10. Linear programming.md>)
  * [Epilogue](<11. Where to go next/11. Epilogue.md>)
* [Answers to exercises](<12. Answers to exercises/README.md>)
  * [Chapter 1](<12. Answers to exercises/Chapter 1.md>)
  * [Chapter 2](<12. Answers to exercises/Chapter 2.md>)
  * [Chapter 3](<12. Answers to exercises/Chapter 3.md>)
  * [Chapter 4](<12. Answers to exercises/Chapter 4.md>)
  * [Chapter 5](<12. Answers to exercises/Chapter 5.md>)
  * [Chapter 6](<12. Answers to exercises/Chapter 6.md>)
  * [Chapter 7](<12. Answers to exercises/Chapter 7.md>)
  * [Chapter 8](<12. Answers to exercises/Chapter 8.md>)
  * [Chapter 9](<12. Answers to exercises/Chapter 9.md>)
  * [Chapter 10](<12. Answers to exercises/Chapter 10.md>)